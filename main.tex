% !TeX spellcheck = russian-aot
% !TeX encoding = UTF-8
% ----------------------------------------------------------------
% plc-sample-2017.tex
% Demonstration of PLC (Programming Languages and Compilers)
%   conference proceedings and articles template file
% http://plc.sfedu.ru/for-authors.html
% Main file
% Created: 20 January, 2017
% ----------------------------------------------------------------
%
% Requirements:
% - UTF-8 encoding;
% - Standard article document class;
% - A4 paper size;
% - 10pt font;
% - Single column;
% - Floating environments for figures (e. g.
%   \begin {figure} ... \end {figure});
% - Authors' emails (optionally) and affiliations in \author command;
% - An abstract and keywords are required;
% - If a BibTeX file is used, it must be in the form: <prefix>-biblio.bib
%   where <prefix> consists of the author's name and an abbreviated
%   organization name;
% - All used labels must be started with the same <prefix>;
% - Volume: - for proceedings: up to 2 pages; for articles: up to 8 pages.
%

\documentclass [a4paper] {article}

% ----------------------------------------------------------------
% Required packages

\usepackage [utf8] {inputenc}
\usepackage [T2A] {fontenc}
\usepackage [english,russian] {babel}

\usepackage {url}

% ----------------------------------------------------------------
% Title settings
\title %
  {Построение синтаксических анализаторов
   на основе алгебраических эффектов}

\author %
{%
  Лукьянов~Г.\,А., \url {glukyanov@sfedu.ru} \and %
  Пеленицын~А.\,М., \url {apel@sfedu.ru} \\
  Южный Федеральный Университет
}%

\date {}    % if desired

% ----------------------------------------------------------------
\begin {document}
% ----------------------------------------------------------------

\maketitle

\begin {abstract}
  %
  Целью работы является исследование применимости современных методов
  контроля вычислительных эффектов к задаче построения функциональных синтаксических анализаторов. В работе рассматривается язык
  программирования~\texttt{Frank}~\cite{Frank}, реализованные в нём концепции
  алгебраических эффектов и обработчиков эффектов и их применение к конструированию функциональных парсеров на основе парсер"=комбинаторов. Описывается текущее состояние
  разрабатываемой авторами с помощью языка~\texttt{Frank} комбинаторной библиотеки.
  %
  \\ \textbf {Ключевые слова:} синтаксический анализ, парсер,
  комбинаторы парсеров, функциональное программирование, вычислительные эффекты,
  алгебраические эффекты, обработчики эффектов.
\end {abstract}

\section*{Введение}

Чисто функциональные языки программирования позволяют формально рассуждать о свойствах программ, но представляют сложность для организации побочных эффектов, которые требуются в большинстве программ. В данной статье обсуждаются два известных подхода к управлению эффектами, и второй из них, более новый, применяется в задаче построения парсер"=комбинаторных библиотек, которая позволяет оценить удобство и гибкость в использовании данного подхода.

\section{Вычислительные эффекты}

Возможность статического контроля побочных эффектов является одним из
принципиальных преимуществ статически типизированных языков
программирования с богатыми системами типов. Отделение <<чистых>> функций от вычислений, обременённых
взаимодействием с глобальным состоянием (например, подсистемой ввода-вывода), позволяет с с большей уверенностью рассуждать о надёжности
разрабатываемой программной системы.

Зачастую бинарного разделения на <<чистые>> и <<эффективные>>
вычисления недостаточно: чтобы увеличить степень контроля над поведением программы,
вводят более точную классификацию эффектов. К примеру, различают вычисления с изменяемым
состоянием и те, которым требуется только фиксированная конфигурация;
другой пример: можно отделять файловый ввод-вывод от межпроцессного взаимодействия. Далее, имея
базовые блоки-эффекты, важно иметь удобный механизм для их комбинирования и
построения сложных вычислений с несколькими побочными эффектами. Для решения
этих проблем существует как минимум два класса методов, общая сведения о которых приведены в данном разделе.

\subsection{Монадический подход}

Исторически первым подходом к типизации вычислений с побочными эффектами
является монадический подход~\cite{Moggi:1989:CLM:77350.77353}. В данном подразделе
кратко рассмотрен монадический подход к описанию и комбинированию
вычислительных эффектов с примерами на языке~\texttt{Haskell}.

Монадами в языке~\texttt{Haskell} являётся типы, которые имеют экземпляр
класса типов~\texttt{Monad}, удовлетворяющий трём законам.
\begin{verbatim}
  class Monad m where
    return :: a -> m a
    (>>=)  :: m a -> (a -> m b) -> m b

  join . return = id
  join . fmap return = id
  join . join = join . fmap join
\end{verbatim}
Описание экземпляра монады даёт абстрактному интерфейсу
интерпретацию с помощью некоторого конкретного типа (например, тип списка имеет свой экземпляр класса \texttt{Monad}).

Дополнительная классификация эффектов в монадическом подходе осуществляется
уточнением интерфейса класса типов~\texttt{Monad}. Типы, используемые для реализации
интерфейсов одновременно нескольких
монадических классов, называются \emph{стеками монад} (или монадическими стеками). Для конструирования
монадических стеков применяются трансформеры монад~\cite{monadTransformers}
--- типы,
добавляющие функционал некоторой конкретной монады к любой другой. Для
языка~\texttt{Haskell} существует популярная библиотека~\texttt{mtl}~\cite{mtlHackage},
предоставляющая базовые средства для программирования с трансформерами монад.

Монадический подход в целом и трансфермеры монад в частности являются зрелой
технологией описания вычислений с побочными эффектами.
Однако, ряд присущих ей недостатков, связанных с комбинированием эффектов,
например, проблема необходимости описания большого числа однотипных
экземпляров классов типов для монадических трансформеров, стимулирует к поиску других методов.

\subsection{Алгебраические эффекты и язык \texttt{Frank}}

Перспективным методом описания вычислений с побочными эффектами, активно
развивающимся в последние годы, является теория алгебраических
эффектов и обработчиков эффектов~\cite{AlgEffects} -- рассмотрим их основные особенности с примерами на экспериментальном языке
программирования~\texttt{Frank}~\cite{Frank}, который имеет встроенную
поддержку указанных концепций.

Основной особенностью алгебраических эффектов является явное разделение
интерфейса и реализации эффекта. Синтаксис эффекта задаётся сигнатурой,
содержащей перечисление предоставляемых операций. Для синтаксиса языка,
определяемого интерфейсом эффекта, нужно задать
семантику --- описать интерпретатор. Для этого применяется концепция
обработчиков эффектов (effects handlers).

\section{Синтаксический анализ как вычисление с эффектами}

В статье~\cite{monParsing} показано, что парсеры могут быть представлены как вычисления, комбинирующие эффекты изменяемого состояния и некорректного завершения. Монадический подход предоставляет
необходимые средства для кодирования этой идеи, что успешно используются в реализациях библиотек
функциональных комбинаторов парсеров (самая известная из таких библиотек~--- Parsec~\cite{parsec}).

Алгебраические эффекты предоставляют альтернативный трансформерам монад подход к
описанию вычислений с несколькими побочными эффектами. Описание парсеров в
терминах алгебраических эффектов и процесса синтаксического разбора в виде
обработки этих эффектов позволяет более ясно увидеть преимущества этих концепций.

\subsection{Эффекты для синтаксического разбора и их обработчики
            в терминах языка~\texttt{Frank}}

Мы представляем синтаксический анализ
как два зависимых эффекта: парсеры единичных символов и парсеры
последовательностей.

Интерфейс парсера для одиночных символов представлен тремя командами: остановкой
вычисления в случае обнаружения синтаксической ошибки, распознаванием символа,
удовлетворяющего предикату, и выбором между двумя парсерами.
\begin{verbatim}
  interface Parser = fail : ParseError -> Char
                   | sat : {Char -> Bool} -> Char
                   | choose : {[Parser] Char} -> {[Parser] Char}
                                              -> Char
\end{verbatim}

Для реализации обработчика эффекта~\texttt{Parser} производится
сопоставление с образцом для команд интерфейса и состояния входного потока.
Команде выбора между двумя парсерами назначается следующая семантика:
производится попытка применения первого парсера, в случае неудачи --- второго, а
если и второй парсер применить не удаётся --- разбор завершается с ошибкой.

Для описания разбора последовательностей символов предлагается эффект
~\texttt{MultiParser}, содержащий две команды: обёртку для разбора одиночного
символа и команду для разбора последовательности символов произвольной длины,
разбираемых данным парсером одиночных символов.
\begin{verbatim}
  interface MultiParser = singleton: {[Parser] Char} -> List Char
                        | many : {[Parser] Char} -> List Char
\end{verbatim}

Имея в распоряжении механизм для разбора последовательностей символов, можно
реализовать парсеры более высокого уровня, которые в последствии могут быть
использован для описания прикладных инструментов, например, для разбора
языков разметки (\texttt{Markdown}, ~\texttt{HTML} и др.).
\begin{verbatim}
  letter : [Parser]Char
  letter! = sat isLetter

  word : [MultiParser](List Char)
  word! = many letter
\end{verbatim}

\section*{Заключение}

В данной работе показано, что традиционный монадический подход к построению парсер"=комбинаторных библиотек может быть переработан с помощью альтернативной концепции алгебраических эффектов и их обработчиков. Следующим шагом в этом исследовании могло бы стать развёрнутое сравнение преимуществ и недостатков обоих подходов. Однако, большинство очевидных вопросов, которые тут возникают --- например, вопрос о производительности полученной в работе библиотеки --- упираются в развитость языка ~\texttt{Frank}. Последний, как было показано в работе, предоставляет удобные средства для эксплуатации
идеи алгебраических эффектов, однако, прикладное программирование требует большей
зрелости от реализации языка: наличия системы модулей, улучшения сообщений об
ошибках компиляции и более развитой инфраструктуры, наконец, замены интерпретатора компилятором.

\bibliographystyle{plain}
\bibliography{lukyanov-sfedu-biblio}{}

% ----------------------------------------------------------------
\end {document}
% ----------------------------------------------------------------

\endinput

% End of File
