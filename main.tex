% !TeX spellcheck = russian-aot
% !TeX encoding = UTF-8
% ----------------------------------------------------------------
% plc-sample-2017.tex
% Demonstration of PLC (Programming Languages and Compilers)
%   conference proceedings and articles template file
% http://plc.sfedu.ru/for-authors.html
% Main file
% Created: 20 January, 2017
% ----------------------------------------------------------------
%
% Requirements:
% - UTF-8 encoding;
% - Standard article document class;
% - A4 paper size;
% - 10pt font;
% - Single column;
% - Floating environments for figures (e. g.
%   \begin {figure} ... \end {figure});
% - Authors' emails (optionally) and affiliations in \author command;
% - An abstract and keywords are required;
% - If a BibTeX file is used, it must be in the form: <prefix>-biblio.bib
%   where <prefix> consists of the author's name and an abbreviated
%   organization name;
% - All used labels must be started with the same <prefix>;
% - Volume: - for proceedings: up to 2 pages; for articles: up to 8 pages.
%

\documentclass [a4paper] {article}

% ----------------------------------------------------------------
% Required packages

\usepackage [utf8] {inputenc}
\usepackage [T2A] {fontenc}
\usepackage [english,russian] {babel}

\usepackage {url}
% \usepackage [style = gost-numeric] {biblatex}

% ----------------------------------------------------------------
% Title settings

% \addbibresource {lukyanov-sfedu-biblio.bib}

% ----------------------------------------------------------------
% Title settings

\title %
  {Построение синтаксических анализаторов
   на основе алгебраических эффектов}

\author %
{%
  Лукьянов~Г.\,А., \url {glukyanov@sfedu.ru} \and %
  Пеленицын~А.\,М., \url {apel@sfedu.ru} \\
  Южный Федеральный Университет
}%

\date {}    % if desired

% ----------------------------------------------------------------
\begin {document}
% ----------------------------------------------------------------

\maketitle

\begin {abstract}
  %
  Целью работы является исследование применимости современных методов
  контроля вычислительных эффектов к задаче построения функциональных синтаксических анализаторов. В работе рассматривается язык
  программирования~\texttt{Frank}~\cite{Frank}, реализованные в нём концепции
  алгебраических эффектов и обработчиков эффектов и их применение к конструированию функциональных парсеров на основе парсер"=комбинаторов. Описывается текущее состояние
  разрабатываемой авторами с помощью языка~\texttt{Frank} комбинаторной библиотеки.
  %
  \\ \textbf {Ключевые слова:} синтаксический анализ, парсер,
  комбинаторы парсеров, функциональное программирование, вычислительные эффекты,
  алгебраические эффекты, обработчики эффектов.
\end {abstract}

\section*{Введение}

Чисто функциональные языки программирования позволяют формально рассуждать о свойствах программ, но представляют сложность для организации побочных эффектов, которые требуются в большинстве программ. В данной статье обсуждаются два известных подхода к управлению эффектами, и второй из них, более новый, применяется в задаче построения парсер"=комбинаторных библиотек, которая позволяет оценить удобство и гибкость в использовании данного подхода.

\section{Вычислительные эффекты}

Возможность статического контроля побочных эффектов является одним из
принципиальных преимуществ статически типизированных языков
программирования с богатыми системами типов. Отделение <<чистых>> функций от вычислений, обременённых
взаимодействием с глобальным состоянием (например, подсистемой ввода-вывода), позволяет с с большей уверенностью рассуждать о надёжности
разрабатываемой программной системы.

Зачастую бинарного разделения на <<чистые>> и <<эффективные>>
вычисления недостаточно: чтобы увеличить степень контроля над поведением программы,
вводят более точную классификацию эффектов. К примеру, различают вычисления с изменяемым
состоянием и те, которым требуется только фиксированная конфигурация;
другой пример: можно отделять файловый ввод-вывод от межпроцессного взаимодействия. Далее, имея
базовые блоки-эффекты, важно иметь удобный механизм для их комбинирования и
построения сложных вычислений с несколькими побочными эффектами. Для решения
этих проблем существует как минимум два класса методов, общая сведения о которых приведены в данном разделе.

\subsection{Монадический подход}

Исторически первым подходом к типизации вычислений с побочными эффектами
является монадический подход~\cite{Moggi:1989:CLM:77350.77353}. В данном подразделе
кратко рассмотрен монадический подход к описанию и комбинированию
вычислительных эффектов с примерами на языке~\texttt{Haskell}.

Монадами в языке~\texttt{Haskell} являётся типы, которые имеют экземпляр
класса типов~\texttt{Monad}, удовлетворяющий трём законам.
\begin{verbatim}
  class Monad m where
    return :: a -> m a
    (>>=)  :: m a -> (a -> m b) -> m b

  join . return = id
  join . fmap return = id
  join . join = join . fmap join
\end{verbatim}
Описание экземпляра монады даёт абстрактному интерфейсу
интерпретацию с помощью некоторого конкретного типа (например, тип списка имеет свой экземпляр класса \texttt{Monad}.

Дополнительная классификация эффектов в монадическом подходе осуществляется
уточнением интерфейса класса типов~\texttt{Monad}. Например, вычисления с
изменяемым состоянием представляются классом типов~\texttt{MonadState}.
\begin{verbatim}
  class (Monad m) => MonadState m where
      get :: m (StateType m)
      put :: (StateType m) -> m ()
\end{verbatim}
Интерфейс класса \texttt{MonadState} имеет две операции: получение текущего состояния и его обновление.

Другим важным вычислительным эффектом является обращение к
неизменяемой конфигурационной информации.
\begin{verbatim}
  class (Monad m) => MonadReader m where
      ask   :: m (EnvType m)
\end{verbatim}

Механизм ограничений на типы позволяет записать тип вычисления \texttt{f}, одновременно работающего с изменяемым состоянием и обращающегося к конфигурационной информации (в данном случае тип возвращаемого значения неважен):
\begin{verbatim}
  f :: (MonadReader m, MonadState m) => m ()
\end{verbatim}
Если в теле вычисления была вызвана функция интерфейса,
который не был указан в типе, произойдёт ошибка компиляции.
Таким образом производится статический контроль над побочными
эффектами.

Типы, используемые для реализации интерфейсов одновременно нескольких
монадических классов, называются \emph{стеками монад} (или монадическими стеками). Для конструирования
монадических стеков применяются трансформеры монад~\cite{monadTransformers}
--- типы,
добавляющие функционал некоторой конкретной монады к любой другой. Для
языка~\texttt{Haskell} существует популярная библиотека~\texttt{mtl}~\cite{mtlHackage},
предоставляющая базовые средства для программирования с трансформерами монад.

Монадический подход в целом и трансфермеры монад в частности являются зрелой,
проверенной временем технологией описания вычислений с побочными эффектами.
Однако, ряд присущих ей недостатков, связанных с комбинированием эффектов,
например, проблема необходимости описания большого числа однотипных
экземпляров классов типов для монадических трансформеров, стимулирует к поиску других методов.

\subsection{Алгебраические эффекты и язык \texttt{Frank}}

Перспективным методом описания вычислений с побочными эффектами, активно
развивающимся в последние годы, является теория алгебраических
эффектов и обработчиков эффектов~\cite{AlgEffects} -- рассмотрим их основные особенности с примерами на экспериментальном языке
программирования~\texttt{Frank}~\cite{Frank}, который имеет встроенную
поддержку указанных концепций.

\texttt{Frank} является статически типизированным функциональным
языком программирования со строгой семантикой и ML-подобный синтаксисом. Он предоставляет специальные средства для
описания интерфейсов алгебраических эффектов и их обработчиков.
Кроме того, система типов~\texttt{Frank} позволяет без дополнительных усилий описывать
функции, оперирующие в контексте любых эффектов. Синтаксис и семантика языка
\texttt{Frank} были представлены на конференции POPL~'17~\cite{Frank}.

Основной особенностью алгебраических эффектов является явное разделение
интерфейса и реализации эффекта. Синтаксис эффекта задаётся сигнатурой,
содержащей перечисление предоставляемых операций. Например, интерфейс
эффекта изменяемого состояния имеет две операции: получение текущего
состояния и его замену на новое.
\begin{verbatim}
  interface State S = get : S
                    | put : S -> Unit
\end{verbatim}
Первая операция не принимает аргументов и имеет в качестве типа возвращаемого
значения тип состояния. Вторая операция принимает новое состояние и возвращает
значение единичного типа (Тип \texttt{Unit} населён единственным значением
\texttt{unit}).

Для синтаксиса языка, определяемого интерфейсом эффекта, нужно задать
семантику --- описать интерпретатор. Для этого применяется концепция
обработчиков эффектов  (effects handlers). Например, эффект \texttt{State}
может быть интерпретирован следующим образом.
\begin{verbatim}
  state : S -> <State S>X -> X              --- 1
  state s <get -> k>    = state s (k s)     --- 2
  state _ <put s -> k>  = state s (k unit)  --- 3
  state _ x             = x                 --- 4
\end{verbatim}

Прокомментируем этот пример подробно. Типовая аннотация (строка~1): синтаксис~\texttt{<State S>X} означает, что вычисление, передаваемое в качестве параметра, может
требовать от~\emph{охватывающего поля эффектов}(англ. \foreignlanguage{english}{ambient effect ability}) эффект~\texttt{<State S>X}.

Строки 2 и 3 определения обработчика специфицируют действия, которые необходимо совершить при получении каждой из команд интерфейса~\texttt{state} (\texttt{get} / \texttt{put}),
для этого производится сопоставление с образцом для так называемых~\emph{запросов} --- команды интерфейса в паре с~\emph{продожением} (англ. continuation).

Строка 4 определения обработчика описывает случай, в котором в качестве второго параметра передаётся не запрос, а обычное значение~--- в этом случае последнее возвращается без изменений.

Отметим, что \texttt{Frank} предоставляет единообразный синтаксис для описания обработчиков эффектов и обычных функций: функция классифицируется как 0-арный обработчик.

\section{Синтаксический анализ как вычисление с эффектами}

В фундаментальной работе~\cite{monParsing} показано, что функциональные парсеры могут быть представлены как вычисления с комбинированием множества эффектов (например, эффектов изменяемого состояния и некорректного завершения). Монадический подход предоставляет
необходимые средства для кодирования этой идеи, что успешно используются в реализациях библиотек
функциональных комбинаторов парсеров (самая известная из таких библиотек~--- Parsec~\cite{parsec}).

Алгебраические эффекты предоставляют альтернативный трансформерам монад подход к
описанию вычислений с несколькими побочными эффектами. Описание парсеров в
терминах алгебраических эффектов и процесса синтаксического разбора в виде
обработки этих эффектов позволяет более ясно увидеть преимущества этих концепций.

\subsection{Эффекты для синтаксического разбора и их обработчики
            в терминах языка~\texttt{Frank}}

Библиотека комбинаторов парсеров, представленная в этом разделе, призвана реализовать идею, высказанную во введении к текущему разделу. Данная разработка является
исследовательским проектом, её интерфейс и реализация могут подвергаться существенным изменениям (то же, впрочем, можно сказать и о языке \texttt{Frank}).

Мы представляем синтаксический анализ
как два зависимых эффекта: парсеры единичных символов и парсеры
последовательностей.

Интерфейс парсера для одиночных символов представлен тремя командами: остановкой
вычисления в случае обнаружения синтаксической ошибки, распознаванием символа,
удовлетворяющего предикату, и выбором между двумя парсерами.
\begin{verbatim}
  interface Parser = fail : ParseError -> Char
                   | sat : {Char -> Bool} -> Char
                   | choose : {[Parser] Char} -> {[Parser] Char}
                                              -> Char
\end{verbatim}

Аналогично обработчику для эффекта~\texttt{State S}, описанному в предыдущем
разделе, реализуется обработчик для эффекта~\texttt{Parser}: производится
сопоставление с образцом для команд интерфейса и состояния входного потока.
Команде выбора между двумя парсерами назначается следующая семантика:
производится попытка применения первого парсера, в случае неудачи --- второго, а
если и второй парсер применить не удаётся --- разбор завершается с ошибкой.
\begin{verbatim}
  runParser : (List Char) -> <Parser>Char ->
              Either ParseError (Pair Char (List Char))
  runParser xs r = right (pair r xs)
  runParser _ <fail err -> _> = left err
  runParser nil <sat p -> k> = left err
  runParser (x::xs) <sat p -> k> =
    if (p x) {runParser xs (k x)} {runParser nil (fail err)}
  runParser xs <choose p1 p2 -> k> =
    on (runParser xs p1!)
      { (right _) -> runParser xs p1!
      | (left err) -> on (runParser xs p2!)
        { (right _) -> runParser xs p2!
        | (left err) -> left err
        }
      }
\end{verbatim}

Для описания разбора последовательностей символов предлагается эффект
~\texttt{MultiParser}, содержащий две команды: обёртку для разбора одиночного
символа и команду для разбора последовательности символов произвольной длины,
разбираемых данным парсером одиночных символов.
\begin{verbatim}
  interface MultiParser = singleton: {[Parser] Char} -> List Char
                        | many : {[Parser] Char} -> List Char
\end{verbatim}
Реализация обработчика в целом аналогична таковой для эффекта~\texttt{Parser}
и опущена для краткости.

Имея в распоряжении механизм для разбора последовательностей символов, можно
реализовать парсеры более высокого уровня, которые в последствии могут быть
использован для описания прикладных инструментов, например, для разбора
языков разметки (\texttt{Markdown}, ~\texttt{HTML} и др.).
\begin{verbatim}
  letter : [Parser]Char
  letter! = sat isLetter

  word : [MultiParser](List Char)
  word! = many letter
\end{verbatim}
Следующая наша цель состоит в разработке парсера легковесного языка разметки
\texttt{Markdown}.

\section*{Заключение}

В данной работе показано, что традиционный монадический подход к построению парсер"=комбинаторных библиотек может быть переработан с помощью альтернативной концепции алгебраических эффектов и их обработчиков. Следующим шагом в этом исследовании могло бы стать развёрнутое сравнение преимуществ и недостатков обоих подходов. Однако, большинство очевидных вопросов, которые тут возникают --- например, вопрос о производительности полученной в работе библиотеки --- упираются в развитость языка ~\texttt{Frank}. Последний, как было показано в работе, предоставляет удобные средства для эксплуатации
идеи алгебраических эффектов, однако, прикладное программирование требует большей
зрелости от реализации языка: наличия системы модулей, улучшения сообщений об
ошибках компиляции и более развитой инфраструктуры, наконец, замены интерпретатора компилятором.

\bibliographystyle{plain}
\bibliography{lukyanov-sfedu-biblio}{}

% ----------------------------------------------------------------
\end {document}
% ----------------------------------------------------------------

\endinput

% End of File
