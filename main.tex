% !TeX spellcheck = russian-aot
% !TeX encoding = UTF-8
% ----------------------------------------------------------------
% plc-sample-2017.tex
% Demonstration of PLC (Programming Languages and Compilers)
%   conference proceedings and articles template file
% http://plc.sfedu.ru/for-authors.html
% Main file
% Created: 20 January, 2017
% ----------------------------------------------------------------
%
% Requirements:
% - UTF-8 encoding;
% - Standard article document class;
% - A4 paper size;
% - 10pt font;
% - Single column;
% - Floating environments for figures (e. g.
%   \begin {figure} ... \end {figure});
% - Authors' emails (optionally) and affiliations in \author command;
% - An abstract and keywords are required;
% - If a BibTeX file is used, it must be in the form: <prefix>-biblio.bib
%   where <prefix> consists of the author's name and an abbreviated
%   organization name;
% - All used labels must be started with the same <prefix>;
% - Volume: - for proceedings: up to 2 pages; for articles: up to 8 pages.
%

\documentclass [a4paper] {article}

% ----------------------------------------------------------------
% Required packages

\usepackage [utf8] {inputenc}
\usepackage [T2A] {fontenc}
\usepackage [english,russian] {babel}

\usepackage {url}
\usepackage [style = gost-numeric] {biblatex}

% ----------------------------------------------------------------
% Title settings

\addbibresource {lukyanov-sfedu-biblio.bib}

% ----------------------------------------------------------------
% Title settings

\title %
  {Метод построения синтаксических анализаторов
   на основе алгебраических эффектов}

\author %
{%
  Лукьянов~Г.\,А., \url {glukyanov@sfedu.ru} \and %
  Пеленицын~А.\,М., \url {apel@sfedu.ru} \\
  Южный Федеральный Университет
}%

\date {}    % if desired

% ----------------------------------------------------------------
\begin {document}
% ----------------------------------------------------------------

\maketitle

\begin {abstract}
  %
  Целью работы является развитие гибких и выразительных методов построения
  функциональных синтаксических анализаторов на основе современных подходов
  к контролю вычислительных эффектов. В работе рассматривается язык
  программирования~\texttt{Frank}~\cite{Frank}, реализованные в нём концепции
  алгебраических эффектов и обработчиков эффектов и их применение к построению
  методов синтаксического анализа. Описывается текущее состояние
  разрабатываемой с использованием языка~\texttt{Frank} библиотеки комбинаторов
  парсеров.
  %
  \\ \textbf {Ключевые слова:} синтаксический анализ, парсер,
  комбинаторы парсеров, функциональное программирование, вычислительные эффекты,
  алгебраические эффекты, обработчики эффектов.
\end {abstract}

Современные типизированные функциональные языки программирования трактуют
типы-функции и типы-значения единообразно. Это позволяет достигнуть высокой
степени выразительности за счёт использования, например, функций высших
порядков (функций, которые могут как принимать в качестве параметров, так и
возвращать другие функции).

\section{Вычислительные эффекты}

Возможность статического контроля побочных эффектов является одним из
принципиальных преимуществ статически типизированных языков
программирования с богатыми системами типов. Отделение ``чистых''
(англ. \emph{pure}) функций от вычислений, имеющих побочные
эффекты, позволяет с большей уверенностью рассуждать о надёжности программного
обеспечения.

Однако, часто такого грубого разделения на ``чистые'' и ``эффективные''
вычисления бывает недостаточно. Чтобы увеличить степень контроля, необходимо
ввести более точную классификацию эффектов: отделить вычисления с изменяемым
состоянием от тех, котором требуется только фиксированная конфигурация, или же
разделить файловый ввод-вывод и межпроцессное взаимодействие. Далее, имея
базовые блоки-эффекты, важно иметь удобный механизм для их комбинирования и
построения сложных вычислений с несколькими побочными эффектами. Для решения
этих проблем существует два класса методов, речь о которых пойдёт далее.

\subsection{Монадический подход}

Исторически первым подходом к типизации вычислений с побочными эффектами
является монадический подход~\cite{Moggi:1989:CLM:77350.77353}, который будет
кратко рассмотрен в этом разделе с примерами на языке~\texttt{Haskell}.

Монадами в языке~\texttt{Haskell} являётся типы, которые имеют экземпляр
класса типов~\texttt{Monad}, удовлетворяющий трём законам
(см. листинг). Описание экземпляр монады даёт абстрактного интерфейсу
интерпретацию с помощью некоторого конкретного типа.

\begin{verbatim}
class Monad m where
  return :: a -> m a
  (>>=)  :: m a -> (a -> m b) -> m b

join . return = id
join . fmap return = id
join . join = join . fmap join
\end{verbatim}

Дополнительная классификация эффектов в монадическом подходе осуществляется
уточнением интерфейса класса типов~\texttt{Monad}. Например, вычисления с
изменяемым состоянием представляются классом типов~\texttt{MonadState}.

\begin{verbatim}
class (Monad m) => MonadState m where
    get :: m (StateType m)
    put :: (StateType m) -> m ()
\end{verbatim}

Интерфейс класса имеет~\texttt{MonadState} две операции: получение текущего
состояния и помещение нового.

Другим важным вычислительным эффектом является обращение к
неизменяемой конфигурационной информации.

\begin{verbatim}
class (Monad m) => MonadReader m where
    ask   :: m (EnvType m)
\end{verbatim}

Механизм ограничений на типы позволяет записать тип вычисления, работающего
с изменяемым состоянием и обращающегося к конфигурационной информации следующим
образом:

\begin{verbatim}
f :: (MonadReader m, MonadState m) => m ()
\end{verbatim}

В случае, если в теле вычисления была вызвана функция интерфейса,
который не был указан в типе --- произойдёт ошибка компиляции.
Таким образом производится статический контроль над побочными
эффектами.

Типы, используемые для реализации интерфейсов одновременно нескольких
монадических классов, называются стеками монад. Для конструирования
монадических стеков применяются трансформеры монад~\cite{monadTransformers}
--- типы высоких порядков,
добавляющие функционал некоторой конкретной монады к любой другой. Для
языка~\texttt{Haskell} существует популярная
библиотека~\texttt{mtl}~\cite{mtlHackage}, предоставляющая машинерию для
программирования с трансформерами монад.

Монадический подход в целом и трансфермеры монад в частности являются зрелой,
проверенной временем технологией описания вычислений с побочными эффектами.
Однако, ряд присущих ей недостатков, связанных с комбинированием эффектов,
например, проблема необходимости описания большого числа однотипных
экземпляров классов типов для монадических трансформеров, мотивирует развитие
других методов. Один из них, набирающий популярность
в течении последних лет, будет будет рассмотрен в следующем разделе.

\subsection{Алгебраические эффекты}

Перспективным методом описания вычислений с побочными эффектами, активно
развивающимся в последние годы, являются теория алгебраических
эффектов и обработчиков эффектов~\cite{AlgEffects}.

Далее будут рассмотрены основные особенности алгебраических эффектов и
обработчиков эффектов и приведены примеры на экспериментальном языке
программирования~\texttt{Frank}~\cite{Frank}, поддерживающем эти концепции на
уровне ядра.

Основной особенностью алгебраических эффектов является явное разделение
интерфейса и реализации эффекта. Синтаксис эффекта задаётся сигнатурой,
содержащей перечисление предоставляемых операций. Например, интерфейс
эффекта изменяемого состояния имеет две операции: получение текущего
состояния и его замену на новое.

\begin{verbatim}
interface State S = get : S
                  | put : S -> Unit
\end{verbatim}

Первая операция не принимает аргументов и имеет в качестве типа возвращаемого
значения тип состояния. Вторая операция принимает новое состояние и возвращает
значение единичного типа (Тип \texttt{Unit} населён единственным значением
\texttt{unit}).

Для синтаксиса языка, определяемого интерфейсом эффекта, нужно задать
семантику --- описать интерпретатор. Для этого применяется концепция
обработчиков эффектов  (effects handlers). Например, эффект \texttt{State}
может быть проинтерпретирован следующим образом.

\begin{verbatim}
state : S -> <State S>X -> X
state s <get -> k>    = state s (k s)
state _ <put s -> k>  = state s (k unit)
state _ x             = x
\end{verbatim}

Frank предоставляет единообразный синтаксис для описания обработчиков эффектов
и обычных функций. При этом функция классифицируется как 0-арный обработчик.
Для описания обработчика~\texttt{state} необходимо произвести сопоставление с
образцом для параметра-вычисления. Синтаксис~\texttt{<State S>X} типовой
аннотации означает, что вычисление, передаваемое в качестве параметра может
требовать от~\emph{охватывающего поля эффектов}(англ. ambient effect ability)
эффект~\texttt{<State S>X}. Следующие две строки определения обработчика
специфицируют действия, которые необходимо совершить при получении каждой из
команд интерфейса~\texttt{state}, для этого производится сопоставление с
образцом для~\emph{запросов} (англ. requests) --- команды интерфейса в паре с
~\emph{продожением} (англ. continuation). Последняя строка определения описывает
случай, в котором в качестве второго параметра передаётся не~\emph{запрос}, а
~\emph{значение}, которое возвращается без изменений.

\section{Синтаксический анализ как вычисление с эффектами}

Показано, что типы, описывающие функциональные парсеры могут быть представлены
как типы вычислений с эффектами изменяемого состояния и некорректного
завершения~\cite{monParsing}. Монадический подход предоставляет
необходимые средства, которые успешно используются для реализации библиотек
функциональных комбинаторов парсеров~\cite{parsec}.

Алгебраические эффекты предоставляют альтернативный трансформерам монад подход к
описанию вычислений с несколькими побочными эффектами. Описание парсеров в
терминах алгебраических эффектов и процесса синтаксического разбора в виде
обработки этих эффектов позволяет использовать преимущества этих концепций
для увеличения выразительности методов синтаксического анализа.

\subsection{Эффекты для синтаксического разбора и их обработчики
            в терминах языка~\texttt{Frank}}

Frank является статически типизированным функциональным
строгим языком программирования, предоставляющим специальный синтаксис для
описания интерфейсов алгебраических эффектов и их обработчиков.
Кроме того, система типов~\texttt{Frank} позволяет без дополнительных усилий описывать
функции, оперирующие в контексте любых эффектов. Синтаксис и семантика языка
Frank были представлены на конференции POPL'17~\cite{Frank}.

Библиотека комбинаторов парсеров, представленной в этом разделе, является
исследовательским проектом, и, как её интерфейс, так и реализация, очень
нестабильны и могут быть подвергнуты существенной переработке.
Ниже будет описан вариант реализации, представляющая синтаксический анализ
как два зависимых эффекта: парсеры единичных символов и парсеры
последовательностей представлены разными сигнатурами эффектов.

Интерфейс парсера для одиночных символов представлен тремя командами: остановкой
вычисления в случае обнаружения синтаксической ошибки, распознаванием символа,
удовлетворяющего предикату и выбором между двумя парсерами.

\begin{verbatim}
interface Parser = fail : ParseError -> Char
                 | sat : {Char -> Bool} -> Char
                 | choose : {[Parser] Char} -> {[Parser] Char} -> Char
\end{verbatim}

Аналогично обработчику для эффекта~\texttt{State S}, описанному в предыдущем
разделе, реализуется обработчик для эффекта~\texttt{Parser}: производится
сопоставление с образцом для команд интерфейса и состояния входного потока.
Команде выбора между двумя парсерами назначается следующая семантика:
производится попытка применения первого парсера, в случае неудачи --- второго, а
если и второй применить не удаётся --- разбор завершается с ошибкой.

\begin{verbatim}
runParser : (List Char) -> <Parser>Char ->
            Either ParseError (Pair Char (List Char))
runParser xs r = right (pair r xs)
runParser _ <fail err -> _> = left err
runParser nil <sat p -> k> = left err
runParser (x::xs) <sat p -> k> =
  if (p x) {runParser xs (k x)} {runParser nil (fail err)}
runParser xs <choose p1 p2 -> k> =
  on (runParser xs p1!)
    { (right _) -> runParser xs p1!
    | (left err) -> on (runParser xs p2!)
      { (right _) -> runParser xs p2!
      | (left err) -> left err
      }
    }
\end{verbatim}

Для описания разбора последовательностей символов предлагается эффект
~\texttt{MultiParser}, содержащий две команды: обёртку для разбора одиночного
символа и команду для разбора последовательности символов произвольной длины,
разбираемых данным парсером одиночных символов.

\begin{verbatim}
interface MultiParser = singleton : {[Parser] Char} -> List Char
                      | many : {[Parser] Char} -> List Char
\end{verbatim}

Реализация обработчика в целом аналогична таковой для эффекта~\texttt{Parser}
и опущена для краткости.

Имея в распоряжении механизм для разбора последовательностей символов, можно
реализовать парсеры более высокого уровня, которые в последствии могут быть
использован для описания прикладных инструментов, например, для разбора
языков разметки (~\texttt{Markdown}, ~\texttt{HTML} и др.).

\begin{verbatim}
letter : [Parser]Char
letter! = sat isLetter

word : [MultiParser](List Char)
word! = many letter
\end{verbatim}

\section{Выводы}

Язык программирования~\texttt{Frank} предоставляет удобные средства для программирования
с алгебраическими эффектами. Однако, прикладное программирование требует большей
зрелости от реализации языка: наличия системы модулей, улучшения сообщений об
ошибках компиляции и более развитой инфраструктуры.

Реализованный на основе алгебраических эффектов прототип библиотеки
~\cite{frankoparsec} синтаксических анализаторов требует сравнения в терминах
удобства и производительности программирования с библиотеками,
основанными на монадическом подходе, таких, как известная библиотека
~\texttt{Parsec}~\cite{parsec} или библиотека, реализованная первым автором в
рамках квалификационной работы бакалавра~\cite{mdParse}.

\printbibliography

% ----------------------------------------------------------------
\end {document}
% ----------------------------------------------------------------

\endinput

% End of File
